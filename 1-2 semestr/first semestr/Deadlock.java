package Treads;

/**
 * Это пример того, как НЕ следует писать многопоточные программы.
 * Это программа, преднамеренно вызывающая взаимную блокировку двух потоков
 * исполнения, каждый из которых пытается захватить ресурс, захваченный
 * другим потоком. Чтобы избежать взаимной блокировки такого рода
 * при множестве захватываемых ресурсов, все потоки должны осуществлять
 * захваты всегда в одном и том же порядке.
 **/

public class Deadlock {
    public static void main(String[] args) {
        // Это два ресурса, которые потоки будут пытаться захватить
        final Object resource1 = "resource1";
        final Object resource2 = "resource2";
        // Это первый поток. Он пытается захватить
        // сначала resource1, а затем resource2
        Thread t1 = new Thread() {
            public void run() {
                // Захват resource1
                synchronized(resource1) {
                    System.out.println("Поток исполнения 1: захвачен resource1");

                    // Небольшая пауза, имитирующая файловый ввод/вывод или
                    // чтоонибудь еще. По существу, мы просто хотим дать
                    // второму потоку шанс стартовать. Потоки исполнения
                    // и взаимная блокировка асинхронны, но мы пытаемся
                    // вызвать здесь взаимную блокировку...
                    //Thread.sleep(50);
                    try { Thread.sleep(50); }
                    catch (InterruptedException e) {}
                    // Теперь ждем, не удастся ли нам захватить resource2
                    synchronized(resource2) {
                        System.out.println("Поток исполнения 1: захвачен resource2");
                    }
                }
            }
        };

        // А вот второй поток исполнения. Он пытается захватить
        // сначала resource2, а затем resource1
        Thread t2 = new Thread() {
            public void run() {
                // Этот поток сразу же захватывает resource2
                synchronized(resource2) {
                    System.out.println("Поток исполнения 2: захвачен resource2");

                    // Теперь, точно так же, как первый поток,
                    // он выдерживает паузу.
                    try { Thread.sleep(50); }
                    catch (InterruptedException e) {}

                    // Теперь он пытается захватить resource1. Но постойте!
                    // Поток 1 захватил resource1 и не отпустит его, пока
                    // не сможет захватить resource2. Этот же поток
                    // удерживает resource2 и не отпустит его, пока
                    // не получит resource1. Мы в тупике. Ни один поток
                    // не может продолжить исполнение, и программа зависает.
                    synchronized(resource1) {
                        System.out.println("Поток исполнения 2: захвачен resource 1");
                    }
                }
            }
        };

        // Запускаем два наших потока исполнения. Если все будет идти по плану,
        // возникнет взаимная блокировка, и программа никогда не завершится.
        t1.start();
        t2.start();
    }
}
